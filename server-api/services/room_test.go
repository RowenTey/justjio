package services

import (
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/RowenTey/JustJio/model"
	"github.com/RowenTey/JustJio/util"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/suite"
	"gorm.io/gorm"
)

type RoomServiceTestSuite struct {
	suite.Suite
	DB   *gorm.DB
	mock sqlmock.Sqlmock

	roomService *RoomService
}

func TestRoomServiceSuite(t *testing.T) {
	suite.Run(t, new(RoomServiceTestSuite))
}

func (s *RoomServiceTestSuite) SetupTest() {
	var err error
	s.DB, s.mock, err = util.SetupTestDB()
	assert.NoError(s.T(), err)

	s.roomService = NewRoomService(s.DB)
}

func (s *RoomServiceTestSuite) AfterTest(_, _ string) {
	assert.NoError(s.T(), s.mock.ExpectationsWereMet())
}

func (s *RoomServiceTestSuite) TestCreateRoom_Success() {
	// arrange
	host := &model.User{
		ID:       1,
		Username: "testuser",
		Email:    "test@example.com",
	}

	room := &model.Room{
		Name:           "Test Room",
		AttendeesCount: 1,
		IsClosed:       false,
	}

	s.mock.ExpectBegin()

	// Mock the room insertion - the UUID will be generated by the BeforeCreate hook
	s.mock.ExpectExec(`INSERT INTO "rooms"`).
		WithArgs(
			sqlmock.AnyArg(),    // ID (UUID) - generated by hook
			room.Name,           // Name
			sqlmock.AnyArg(),    // Time
			sqlmock.AnyArg(),    // Venue
			sqlmock.AnyArg(),    // Date
			host.ID,             // HostID
			room.AttendeesCount, // AttendeesCount
			sqlmock.AnyArg(),    // CreatedAt
			sqlmock.AnyArg(),    // UpdatedAt
			room.IsClosed,       // IsClosed
		).
		WillReturnResult(sqlmock.NewResult(1, 1))

	// Before creating room_user, gorm will try to insert host into users table again
	s.mock.ExpectQuery(`INSERT INTO "users"`).
		WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1))

	// Mock the room-user relationship
	s.mock.ExpectExec(`INSERT INTO "room_users"`).
		WithArgs(sqlmock.AnyArg(), host.ID).
		WillReturnResult(sqlmock.NewResult(1, 1))

	s.mock.ExpectCommit()

	// act
	createdRoom, err := s.roomService.CreateRoom(room, host)

	// assert
	assert.NoError(s.T(), err)
	assert.NotNil(s.T(), createdRoom)
	assert.Equal(s.T(), host.ID, createdRoom.HostID)
	assert.Len(s.T(), createdRoom.Users, 1)
	assert.Equal(s.T(), host.ID, createdRoom.Users[0].ID)
	assert.False(s.T(), createdRoom.CreatedAt.IsZero())
	assert.False(s.T(), createdRoom.UpdatedAt.IsZero())
}

func (s *RoomServiceTestSuite) TestGetRooms_Success() {
	// arrange
	userID := "1"
	page := 1
	now := time.Now()

	expectedRooms := []model.Room{
		{
			ID:             "1",
			Name:           "Room 1",
			HostID:         1,
			AttendeesCount: 2,
			IsClosed:       false,
			CreatedAt:      now,
			UpdatedAt:      now,
		},
		{
			ID:             "2",
			Name:           "Room 2",
			HostID:         2,
			AttendeesCount: 3,
			IsClosed:       false,
			CreatedAt:      now.Add(-1 * time.Hour),
			UpdatedAt:      now.Add(-1 * time.Hour),
		},
	}

	rows := sqlmock.NewRows([]string{
		"id", "name", "host_id",
		"attendees_count", "is_closed", "created_at", "updated_at",
	})

	for _, room := range expectedRooms {
		rows.AddRow(
			room.ID, room.Name, room.HostID,
			room.AttendeesCount, room.IsClosed,
			room.CreatedAt, room.UpdatedAt,
		)
	}

	s.mock.ExpectQuery(`SELECT "rooms"."id","rooms"."name","rooms"."time","rooms"."venue","rooms"."date","rooms"."host_id","rooms"."attendees_count","rooms"."created_at","rooms"."updated_at","rooms"."is_closed" FROM "rooms" JOIN room_users ON rooms.id = room_users.room_id WHERE room_users.user_id = \$1 AND rooms.is_closed = \$2 ORDER BY rooms.updated_at DESC LIMIT \$3`).
		WithArgs(userID, false, ROOM_PAGE_SIZE).
		WillReturnRows(rows)

	// act
	resultRooms, err := s.roomService.GetRooms(userID, page)

	// assert
	assert.NoError(s.T(), err)
	assert.NotNil(s.T(), resultRooms)
	assert.Len(s.T(), *resultRooms, 2)
	assert.Equal(s.T(), expectedRooms[0].ID, (*resultRooms)[0].ID)
	assert.Equal(s.T(), expectedRooms[1].ID, (*resultRooms)[1].ID)
}

func (s *RoomServiceTestSuite) TestGetNumRooms_Success() {
	// arrange
	userID := "1"
	expectedCount := int64(5)

	rows := sqlmock.NewRows([]string{"count"}).
		AddRow(expectedCount)

	s.mock.ExpectQuery(`SELECT count\(\*\) FROM "rooms" JOIN room_users ON rooms.id = room_users.room_id WHERE room_users.user_id = \$1`).
		WithArgs(userID).
		WillReturnRows(rows)

	// act
	count, err := s.roomService.GetNumRooms(userID)

	// assert
	assert.NoError(s.T(), err)
	assert.Equal(s.T(), expectedCount, count)
}

func (s *RoomServiceTestSuite) TestGetRoomById_Success() {
	// arrange
	roomID := "1"
	now := time.Now()

	expectedRoom := model.Room{
		ID:             "1",
		Name:           "Test Room",
		HostID:         1,
		AttendeesCount: 2,
		IsClosed:       false,
		CreatedAt:      now,
		UpdatedAt:      now,
	}

	rows := sqlmock.NewRows([]string{
		"id", "name", "host_id",
		"attendees_count", "is_closed", "created_at", "updated_at",
	}).AddRow(
		expectedRoom.ID, expectedRoom.Name, expectedRoom.HostID,
		expectedRoom.AttendeesCount, expectedRoom.IsClosed,
		expectedRoom.CreatedAt, expectedRoom.UpdatedAt,
	)

	s.mock.ExpectQuery(`SELECT \* FROM "rooms" WHERE id = \$1 ORDER BY "rooms"."id" LIMIT \$2`).
		WithArgs(roomID, 1).
		WillReturnRows(rows)

	// act
	room, err := s.roomService.GetRoomById(roomID)

	// assert
	assert.NoError(s.T(), err)
	assert.NotNil(s.T(), room)
	assert.Equal(s.T(), expectedRoom.ID, room.ID)
	assert.Equal(s.T(), expectedRoom.Name, room.Name)
	assert.Equal(s.T(), expectedRoom.HostID, room.HostID)
}

func (s *RoomServiceTestSuite) TestGetRoomById_NotFound() {
	// arrange
	roomID := "999"

	s.mock.ExpectQuery(`SELECT \* FROM "rooms" WHERE id = \$1 ORDER BY "rooms"."id" LIMIT \$2`).
		WithArgs(roomID, 1).
		WillReturnError(gorm.ErrRecordNotFound)

	// act
	room, err := s.roomService.GetRoomById(roomID)

	// assert
	assert.Error(s.T(), err)
	assert.Nil(s.T(), room)
	assert.ErrorIs(s.T(), err, gorm.ErrRecordNotFound)
}

func (s *RoomServiceTestSuite) TestGetRoomInvites_Success() {
	// arrange
	userID := "1"
	now := time.Now()

	expectedInvites := []model.RoomInvite{
		{
			ID:        1,
			RoomID:    "1",
			UserID:    1,
			InviterID: 2,
			Status:    "pending",
			CreatedAt: now,
		},
		{
			ID:        2,
			RoomID:    "2",
			UserID:    1,
			InviterID: 3,
			Status:    "pending",
			CreatedAt: now.Add(-1 * time.Hour),
		},
	}

	rows := sqlmock.NewRows([]string{
		"id", "room_id", "user_id", "inviter_id", "status", "created_at",
	})

	for _, invite := range expectedInvites {
		rows.AddRow(
			invite.ID, invite.RoomID, invite.UserID, invite.InviterID,
			invite.Status, invite.CreatedAt,
		)
	}

	// We need to mock the preloads as well
	roomRows := sqlmock.NewRows([]string{"id", "name", "host_id"}).
		AddRow(1, "Room 1", 2).
		AddRow(2, "Room 2", 3)

	userRows := sqlmock.NewRows([]string{"id", "username"}).
		AddRow(1, "user1")

	inviterRows := sqlmock.NewRows([]string{"id", "username"}).
		AddRow(2, "inviter1").
		AddRow(3, "inviter2")

	hostRows := sqlmock.NewRows([]string{"id", "username"}).
		AddRow(2, "host1").
		AddRow(3, "host2")

	s.mock.ExpectQuery(`SELECT \* FROM "room_invites" WHERE user_id = \$1 AND status = \$2`).
		WithArgs(userID, "pending").
		WillReturnRows(rows)

	// Mock preloads
	s.mock.ExpectQuery(`SELECT \* FROM "users" WHERE "users"."id" IN \(\$1,\$2\)`).
		WillReturnRows(inviterRows)

	s.mock.ExpectQuery(`SELECT \* FROM "rooms" WHERE "rooms"."id" IN \(\$1,\$2\)`).
		WillReturnRows(roomRows)

	s.mock.ExpectQuery(`SELECT \* FROM "users" WHERE "users"."id" IN \(\$1,\$2\)`).
		WillReturnRows(hostRows)

	s.mock.ExpectQuery(`SELECT \* FROM "users" WHERE "users"."id" = \$1`).
		WithArgs(1).
		WillReturnRows(userRows)

	// act
	invites, err := s.roomService.GetRoomInvites(userID)

	// assert
	assert.NoError(s.T(), err)
	assert.NotNil(s.T(), invites)
	assert.Len(s.T(), *invites, 2)
}

func (s *RoomServiceTestSuite) TestGetNumRoomInvites_Success() {
	// arrange
	userID := "1"
	expectedCount := int64(3)

	rows := sqlmock.NewRows([]string{"count"}).
		AddRow(expectedCount)

	s.mock.ExpectQuery(`SELECT count\(\*\) FROM "room_invites" WHERE user_id = \$1 AND status = \$2`).
		WithArgs(userID, "pending").
		WillReturnRows(rows)

	// act
	count, err := s.roomService.GetNumRoomInvites(userID)

	// assert
	assert.NoError(s.T(), err)
	assert.Equal(s.T(), expectedCount, count)
}

func (s *RoomServiceTestSuite) TestGetRoomAttendees_Success() {
	// arrange
	roomID := "1"
	expectedUsers := []model.User{
		{
			ID:       1,
			Username: "user1",
		},
		{
			ID:       2,
			Username: "user2",
		},
	}

	// Mock room query first
	roomRows := sqlmock.NewRows([]string{
		"id", "name", "time", "venue", "date", "host_id",
		"attendees_count", "created_at", "updated_at", "is_closed",
	}).AddRow(
		roomID, "Test Room", "2:00 PM", "Test Venue", time.Now(), 1,
		2, time.Now(), time.Now(), false,
	)

	s.mock.ExpectQuery(`SELECT \* FROM "rooms" WHERE id = \$1 ORDER BY "rooms"."id" LIMIT \$2`).
		WithArgs(roomID, sqlmock.AnyArg()).
		WillReturnRows(roomRows)

	// Mock the join table query
	joinRows := sqlmock.NewRows([]string{"room_id", "user_id"}).
		AddRow(roomID, 1).
		AddRow(roomID, 2)

	s.mock.ExpectQuery(`SELECT \* FROM "room_users" WHERE "room_users"."room_id" = \$1`).
		WithArgs(roomID).
		WillReturnRows(joinRows)

	// Mock the users query
	userRows := sqlmock.NewRows([]string{
		"id", "username", "email", "password", "picture_url",
		"is_email_valid", "is_online", "last_seen", "registered_at", "updated_at",
	})

	for _, user := range expectedUsers {
		userRows.AddRow(
			user.ID, user.Username, "user@example.com", "password",
			"", true, false, time.Now(), time.Now(), time.Now(),
		)
	}

	s.mock.ExpectQuery(`SELECT \* FROM "users" WHERE "users"."id" IN \(\$1,\$2\)`).
		WithArgs(1, 2).
		WillReturnRows(userRows)

	// act
	users, err := s.roomService.GetRoomAttendees(roomID)

	// assert
	assert.NoError(s.T(), err)
	assert.NotNil(s.T(), users)
	assert.Len(s.T(), *users, 2)
	assert.Equal(s.T(), expectedUsers[0].ID, (*users)[0].ID)
	assert.Equal(s.T(), expectedUsers[1].ID, (*users)[1].ID)
}

func (s *RoomServiceTestSuite) TestGetRoomAttendeesIds_Success() {
	// arrange
	roomID := "1"
	expectedUsers := []model.User{
		{
			ID:       1,
			Username: "user1",
		},
		{
			ID:       2,
			Username: "user2",
		},
	}

	// Mock room query first
	roomRows := sqlmock.NewRows([]string{
		"id", "name", "time", "venue", "date", "host_id",
		"attendees_count", "created_at", "updated_at", "is_closed",
	}).AddRow(
		roomID, "Test Room", "2:00 PM", "Test Venue", time.Now(), 1,
		2, time.Now(), time.Now(), false,
	)

	s.mock.ExpectQuery(`SELECT \* FROM "rooms" WHERE id = \$1 ORDER BY "rooms"."id" LIMIT \$2`).
		WithArgs(roomID, sqlmock.AnyArg()).
		WillReturnRows(roomRows)

	// Mock the join table query
	joinRows := sqlmock.NewRows([]string{"room_id", "user_id"}).
		AddRow(roomID, 1).
		AddRow(roomID, 2)

	s.mock.ExpectQuery(`SELECT \* FROM "room_users" WHERE "room_users"."room_id" = \$1`).
		WithArgs(roomID).
		WillReturnRows(joinRows)

	// Mock the users query
	userRows := sqlmock.NewRows([]string{
		"id", "username", "email", "password", "picture_url",
		"is_email_valid", "is_online", "last_seen", "registered_at", "updated_at",
	})

	for _, user := range expectedUsers {
		userRows.AddRow(
			user.ID, user.Username, "user@example.com", "password",
			"", true, false, time.Now(), time.Now(), time.Now(),
		)
	}

	s.mock.ExpectQuery(`SELECT \* FROM "users" WHERE "users"."id" IN \(\$1,\$2\)`).
		WithArgs(1, 2).
		WillReturnRows(userRows)

	// act
	userIds, err := s.roomService.GetRoomAttendeesIds(roomID)

	// assert
	assert.NoError(s.T(), err)
	assert.NotNil(s.T(), userIds)
	assert.Len(s.T(), *userIds, 2)
	assert.Equal(s.T(), "1", (*userIds)[0])
	assert.Equal(s.T(), "2", (*userIds)[1])
}

func (s *RoomServiceTestSuite) TestCloseRoom_Success() {
	// arrange
	roomID := "1"
	userID := "1"
	now := time.Now()

	room := model.Room{
		ID:             roomID,
		Name:           "Test Room",
		HostID:         1,
		AttendeesCount: 2,
		IsClosed:       false,
		CreatedAt:      now.Add(-1 * time.Hour),
		UpdatedAt:      now.Add(-1 * time.Hour),
	}

	// Find room
	roomRows := sqlmock.NewRows([]string{
		"id", "name", "host_id",
		"attendees_count", "is_closed", "created_at", "updated_at",
	}).AddRow(
		room.ID, room.Name, room.HostID,
		room.AttendeesCount, room.IsClosed,
		room.CreatedAt, room.UpdatedAt,
	)

	s.mock.ExpectQuery(`SELECT \* FROM "rooms" WHERE id = \$1 ORDER BY "rooms"."id" LIMIT \$2`).
		WithArgs(roomID, 1).
		WillReturnRows(roomRows)

	// Update room
	s.mock.ExpectBegin()
	s.mock.ExpectExec(`UPDATE "rooms" SET "name"=\$1,"time"=\$2,"venue"=\$3,"date"=\$4,"host_id"=\$5,"attendees_count"=\$6,"created_at"=\$7,"updated_at"=\$8,"is_closed"=\$9 WHERE "id" = \$10`).
		WithArgs(room.Name, room.Time, room.Venue, room.Date, room.HostID, room.AttendeesCount, room.CreatedAt, sqlmock.AnyArg(), true, roomID).
		WillReturnResult(sqlmock.NewResult(1, 1))
	s.mock.ExpectCommit()

	// Delete invites
	s.mock.ExpectBegin()
	s.mock.ExpectExec(`DELETE FROM "room_invites" WHERE room_id = \$1 AND status = \$2`).
		WithArgs(roomID, "pending").
		WillReturnResult(sqlmock.NewResult(0, 2)) // Deleted 2 invites
	s.mock.ExpectCommit()

	// act
	err := s.roomService.CloseRoom(roomID, userID)

	// assert
	assert.NoError(s.T(), err)
}

func (s *RoomServiceTestSuite) TestCloseRoom_NotHost() {
	// arrange
	roomID := "1"
	userID := "2" // Different from host ID
	now := time.Now()

	room := model.Room{
		ID:             roomID,
		Name:           "Test Room",
		HostID:         1, // Host ID is 1, not 2
		AttendeesCount: 2,
		IsClosed:       false,
		CreatedAt:      now.Add(-1 * time.Hour),
		UpdatedAt:      now.Add(-1 * time.Hour),
	}

	// Find room
	roomRows := sqlmock.NewRows([]string{
		"id", "name", "host_id",
		"attendees_count", "is_closed", "created_at", "updated_at",
	}).AddRow(
		room.ID, room.Name, room.HostID,
		room.AttendeesCount, room.IsClosed,
		room.CreatedAt, room.UpdatedAt,
	)

	s.mock.ExpectQuery(`SELECT \* FROM "rooms" WHERE id = \$1 ORDER BY "rooms"."id" LIMIT \$2`).
		WithArgs(roomID, 1).
		WillReturnRows(roomRows)

	// act
	err := s.roomService.CloseRoom(roomID, userID)

	// assert
	assert.Error(s.T(), err)
	assert.Contains(s.T(), err.Error(), "user is not the host of the room")
}

func (s *RoomServiceTestSuite) TestUpdateRoomInviteStatus_Accept() {
	// arrange
	roomID := "1"
	userID := "2"
	status := "accepted"

	// Update invite status
	s.mock.ExpectBegin()
	s.mock.ExpectExec(`UPDATE "room_invites" SET "status"=\$1 WHERE room_id = \$2 AND user_id = \$3`).
		WithArgs(status, roomID, userID).
		WillReturnResult(sqlmock.NewResult(1, 1))
	s.mock.ExpectCommit()

	// Find room
	roomRows := sqlmock.NewRows([]string{
		"id", "name", "host_id", "attendees_count", "is_closed",
	}).AddRow(roomID, "Test Room", 1, 1, false)

	s.mock.ExpectQuery(`SELECT \* FROM "rooms" WHERE id = \$1 ORDER BY "rooms"."id" LIMIT \$2`).
		WithArgs(roomID, 1).
		WillReturnRows(roomRows)

	// Find user
	userRows := sqlmock.NewRows([]string{
		"id", "username",
	}).AddRow(2, "user2")

	s.mock.ExpectQuery(`SELECT \* FROM "users" WHERE "users"."id" = \$1 ORDER BY "users"."id" LIMIT \$2`).
		WithArgs(userID, 1).
		WillReturnRows(userRows)

	// Save room (update attendees)
	s.mock.ExpectBegin()
	s.mock.ExpectExec(`UPDATE "rooms" SET "name"=\$1,"time"=\$2,"venue"=\$3,"date"=\$4,"host_id"=\$5,"attendees_count"=\$6,"created_at"=\$7,"updated_at"=\$8,"is_closed"=\$9 WHERE "id" = \$10`).
		WithArgs("Test Room", sqlmock.AnyArg(), sqlmock.AnyArg(), sqlmock.AnyArg(), 1, 2, sqlmock.AnyArg(), sqlmock.AnyArg(), false, roomID).
		WillReturnResult(sqlmock.NewResult(1, 1))
	s.mock.ExpectQuery(`INSERT INTO "users"`).
		WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(2))
	s.mock.ExpectExec(`INSERT INTO "room_users"`).
		WithArgs(roomID, 2).
		WillReturnResult(sqlmock.NewResult(1, 1))
	s.mock.ExpectCommit()

	// act
	err := s.roomService.UpdateRoomInviteStatus(roomID, userID, status)

	// assert
	assert.NoError(s.T(), err)
}

func (s *RoomServiceTestSuite) TestUpdateRoomInviteStatus_Reject() {
	// arrange
	roomID := "1"
	userID := "2"
	status := "rejected"

	// Update invite status
	s.mock.ExpectBegin()
	s.mock.ExpectExec(`UPDATE "room_invites" SET "status"=\$1 WHERE room_id = \$2 AND user_id = \$3`).
		WithArgs(status, roomID, userID).
		WillReturnResult(sqlmock.NewResult(1, 1))
	s.mock.ExpectCommit()

	// act
	err := s.roomService.UpdateRoomInviteStatus(roomID, userID, status)

	// assert
	assert.NoError(s.T(), err)
}

func (s *RoomServiceTestSuite) TestUpdateRoomInviteStatus_InvalidStatus() {
	// arrange
	roomID := "1"
	userID := "2"
	invalidStatus := "invalid"

	// act
	err := s.roomService.UpdateRoomInviteStatus(roomID, userID, invalidStatus)

	// assert
	assert.Error(s.T(), err)
	assert.Contains(s.T(), err.Error(), "invalid status")
}

func (s *RoomServiceTestSuite) TestJoinRoom_Success() {
	// arrange
	roomID := "1"
	userID := "2"
	now := time.Now()

	// Find room
	roomRows := sqlmock.NewRows([]string{
		"id", "name", "time", "venue", "date", "host_id",
		"attendees_count", "created_at", "updated_at", "is_closed",
	}).AddRow(
		roomID, "Test Room", "2:00 PM", "Test Venue", now, 1,
		1, now, now, false,
	)

	s.mock.ExpectQuery(`SELECT \* FROM "rooms" WHERE id = \$1 ORDER BY "rooms"."id" LIMIT \$2`).
		WithArgs(roomID, 1).
		WillReturnRows(roomRows)

	// Find user
	userRows := sqlmock.NewRows([]string{
		"id", "username", "email", "password", "picture_url",
		"is_email_valid", "is_online", "last_seen", "registered_at", "updated_at",
	}).AddRow(
		2, "user2", "user@test.com", "12345", "https://defaultimage.com",
		false, false, time.Time{}, now, now,
	)

	s.mock.ExpectQuery(`SELECT \* FROM "users" WHERE "users"."id" = \$1 ORDER BY "users"."id" LIMIT \$2`).
		WithArgs(userID, 1).
		WillReturnRows(userRows)

	// Check if user already in room
	s.mock.ExpectQuery(`SELECT count\(\*\) FROM "rooms" JOIN room_users ON rooms.id = room_users.room_id WHERE rooms.id = \$1 AND room_users.user_id = \$2`).
		WithArgs(roomID, userID).
		WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(0))

	// Save room (update attendees)
	s.mock.ExpectBegin()
	s.mock.ExpectExec(`UPDATE "rooms" SET "name"=\$1,"time"=\$2,"venue"=\$3,"date"=\$4,"host_id"=\$5,"attendees_count"=\$6,"created_at"=\$7,"updated_at"=\$8,"is_closed"=\$9 WHERE "id" = \$10`).
		WithArgs(
			sqlmock.AnyArg(),
			sqlmock.AnyArg(),
			sqlmock.AnyArg(),
			sqlmock.AnyArg(),
			sqlmock.AnyArg(),
			2, // attendees_count increased to 2
			sqlmock.AnyArg(),
			sqlmock.AnyArg(),
			sqlmock.AnyArg(),
			roomID).
		WillReturnResult(sqlmock.NewResult(1, 1))

	// GORM checks if user exists first
	s.mock.ExpectQuery(`INSERT INTO "users"`).
		WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(2))

	// Then inserts into the junction table
	s.mock.ExpectExec(`INSERT INTO "room_users"`).
		WithArgs(roomID, 2).
		WillReturnResult(sqlmock.NewResult(1, 1))

	// Don't forget to expect the commit
	s.mock.ExpectCommit()

	// act
	err := s.roomService.JoinRoom(roomID, userID)

	// assert
	assert.NoError(s.T(), err)
}

func (s *RoomServiceTestSuite) TestJoinRoom_AlreadyJoined() {
	// arrange
	roomID := "1"
	userID := "2"
	now := time.Now()

	// Find room
	roomRows := sqlmock.NewRows([]string{
		"id", "name", "host_id", "attendees_count", "is_closed", "created_at", "updated_at",
	}).AddRow(roomID, "Test Room", 1, 1, false, now, now)

	s.mock.ExpectQuery(`SELECT \* FROM "rooms" WHERE id = \$1 ORDER BY "rooms"."id" LIMIT \$2`).
		WithArgs(roomID, 1).
		WillReturnRows(roomRows)

	// Find user
	userRows := sqlmock.NewRows([]string{
		"id", "username",
	}).AddRow(2, "user2")

	s.mock.ExpectQuery(`SELECT \* FROM "users" WHERE "users"."id" = \$1 ORDER BY "users"."id" LIMIT \$2`).
		WithArgs(userID, 1).
		WillReturnRows(userRows)

	// Check if user already in room - return 1 to indicate already joined
	s.mock.ExpectQuery(`SELECT count\(\*\) FROM "rooms" JOIN room_users ON rooms.id = room_users.room_id WHERE rooms.id = \$1 AND room_users.user_id = \$2`).
		WithArgs(roomID, userID).
		WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(1))

	// act
	err := s.roomService.JoinRoom(roomID, userID)

	// assert
	assert.Error(s.T(), err)
	assert.Contains(s.T(), err.Error(), "user is already in room")
}

func (s *RoomServiceTestSuite) TestInviteUserToRoom_Success() {
	// arrange
	roomID := "1"
	now := time.Now()

	inviter := &model.User{
		ID:       1,
		Username: "hostuser",
		Email:    "host@test.com",
	}

	users := &[]model.User{
		{
			ID:       2,
			Username: "user2",
			Email:    "user2@test.com",
		},
		{
			ID:       3,
			Username: "user3",
			Email:    "user3@test.com",
		},
	}

	message := "Please join my room!"

	// Find room
	roomRows := sqlmock.NewRows([]string{
		"id", "name", "time", "venue", "date", "host_id",
		"attendees_count", "created_at", "updated_at", "is_closed",
	}).AddRow(
		roomID, "Test Room", "2:00 PM", "Test Venue", now, inviter.ID,
		1, now, now, false,
	)

	s.mock.ExpectQuery(`SELECT \* FROM "rooms" WHERE id = \$1 ORDER BY "rooms"."id" LIMIT \$2`).
		WithArgs(roomID, 1).
		WillReturnRows(roomRows)

	// Check if user2 is already in room
	s.mock.ExpectQuery(`SELECT count\(\*\) FROM "rooms" JOIN room_users ON rooms.id = room_users.room_id WHERE rooms.id = \$1 AND room_users.user_id = \$2`).
		WithArgs(roomID, uint(2)).
		WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(0))

	// Check if user2 has pending invite
	s.mock.ExpectQuery(`SELECT count\(\*\) FROM "room_invites" WHERE room_id = \$1 AND user_id = \$2 AND status = \$3`).
		WithArgs(roomID, uint(2), "pending").
		WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(0))

	// Check if user3 is already in room
	s.mock.ExpectQuery(`SELECT count\(\*\) FROM "rooms" JOIN room_users ON rooms.id = room_users.room_id WHERE rooms.id = \$1 AND room_users.user_id = \$2`).
		WithArgs(roomID, uint(3)).
		WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(0))

	// Check if user3 has pending invite
	s.mock.ExpectQuery(`SELECT count\(\*\) FROM "room_invites" WHERE room_id = \$1 AND user_id = \$2 AND status = \$3`).
		WithArgs(roomID, uint(3), "pending").
		WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(0))

	// Create room invites
	s.mock.ExpectBegin()
	s.mock.ExpectQuery(`INSERT INTO "room_invites"`).
		WithArgs(
			roomID, uint(2), uint(1), "pending", message, sqlmock.AnyArg(),
			roomID, uint(3), uint(1), "pending", message, sqlmock.AnyArg(),
		).
		WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1).AddRow(2))
	s.mock.ExpectCommit()

	// act
	invites, err := s.roomService.InviteUserToRoom(roomID, inviter, users, message)

	// assert
	assert.NoError(s.T(), err)
	assert.NotNil(s.T(), invites)
	assert.Len(s.T(), *invites, 2)
	assert.Equal(s.T(), roomID, (*invites)[0].RoomID)
	assert.Equal(s.T(), uint(1), (*invites)[0].InviterID)
	assert.Equal(s.T(), uint(2), (*invites)[0].UserID)
	assert.Equal(s.T(), message, (*invites)[0].Message)
}

func (s *RoomServiceTestSuite) TestInviteUserToRoom_UserAlreadyInRoom() {
	// arrange
	roomID := "1"
	now := time.Now()

	inviter := &model.User{
		ID:       1,
		Username: "hostuser",
		Email:    "host@test.com",
	}

	users := &[]model.User{
		{
			ID:       2,
			Username: "user2",
			Email:    "user2@test.com",
		},
	}

	message := "Please join my room!"

	// Find room
	roomRows := sqlmock.NewRows([]string{
		"id", "name", "time", "venue", "date", "host_id",
		"attendees_count", "created_at", "updated_at", "is_closed",
	}).AddRow(
		roomID, "Test Room", "2:00 PM", "Test Venue", now, inviter.ID,
		1, now, now, false,
	)

	s.mock.ExpectQuery(`SELECT \* FROM "rooms" WHERE id = \$1 ORDER BY "rooms"."id" LIMIT \$2`).
		WithArgs(roomID, 1).
		WillReturnRows(roomRows)

	// Check if user2 is already in room - return 1 to indicate user is already in the room
	s.mock.ExpectQuery(`SELECT count\(\*\) FROM "rooms" JOIN room_users ON rooms.id = room_users.room_id WHERE rooms.id = \$1 AND room_users.user_id = \$2`).
		WithArgs(roomID, uint(2)).
		WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(1))

	// act
	invites, err := s.roomService.InviteUserToRoom(roomID, inviter, users, message)

	// assert
	assert.Error(s.T(), err)
	assert.Nil(s.T(), invites)
	assert.Contains(s.T(), err.Error(), "user is already in room")
}

func (s *RoomServiceTestSuite) TestInviteUserToRoom_UserAlreadyInvited() {
	// arrange
	roomID := "1"
	now := time.Now()

	inviter := &model.User{
		ID:       1,
		Username: "hostuser",
		Email:    "host@test.com",
	}

	users := &[]model.User{
		{
			ID:       2,
			Username: "user2",
			Email:    "user2@test.com",
		},
	}

	message := "Please join my room!"

	// Find room
	roomRows := sqlmock.NewRows([]string{
		"id", "name", "time", "venue", "date", "host_id",
		"attendees_count", "created_at", "updated_at", "is_closed",
	}).AddRow(
		roomID, "Test Room", "2:00 PM", "Test Venue", now, inviter.ID,
		1, now, now, false,
	)

	s.mock.ExpectQuery(`SELECT \* FROM "rooms" WHERE id = \$1 ORDER BY "rooms"."id" LIMIT \$2`).
		WithArgs(roomID, 1).
		WillReturnRows(roomRows)

	// Check if user2 is already in room
	s.mock.ExpectQuery(`SELECT count\(\*\) FROM "rooms" JOIN room_users ON rooms.id = room_users.room_id WHERE rooms.id = \$1 AND room_users.user_id = \$2`).
		WithArgs(roomID, uint(2)).
		WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(0))

	// Check if user2 has pending invite - return 1 to indicate pending invite exists
	s.mock.ExpectQuery(`SELECT count\(\*\) FROM "room_invites" WHERE room_id = \$1 AND user_id = \$2 AND status = \$3`).
		WithArgs(roomID, uint(2), "pending").
		WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(1))

	// act
	invites, err := s.roomService.InviteUserToRoom(roomID, inviter, users, message)

	// assert
	assert.Error(s.T(), err)
	assert.Nil(s.T(), invites)
	assert.Contains(s.T(), err.Error(), "user already has pending invite")
}

func (s *RoomServiceTestSuite) TestInviteUserToRoom_NotHost() {
	// arrange
	roomID := "1"
	now := time.Now()

	inviter := &model.User{
		ID:       2, // Not the host
		Username: "nothost",
		Email:    "nothost@test.com",
	}

	users := &[]model.User{
		{
			ID:       3,
			Username: "user3",
			Email:    "user3@test.com",
		},
	}

	message := "Please join my room!"

	// Find room with different host ID
	roomRows := sqlmock.NewRows([]string{
		"id", "name", "time", "venue", "date", "host_id",
		"attendees_count", "created_at", "updated_at", "is_closed",
	}).AddRow(
		roomID, "Test Room", "2:00 PM", "Test Venue", now, uint(1), // Host ID is 1
		1, now, now, false,
	)

	s.mock.ExpectQuery(`SELECT \* FROM "rooms" WHERE id = \$1 ORDER BY "rooms"."id" LIMIT \$2`).
		WithArgs(roomID, 1).
		WillReturnRows(roomRows)

	// act
	invites, err := s.roomService.InviteUserToRoom(roomID, inviter, users, message)

	// assert
	assert.Error(s.T(), err)
	assert.Nil(s.T(), invites)
	assert.Contains(s.T(), err.Error(), "user is not the host of the room")
}

func (s *RoomServiceTestSuite) TestInviteUserToRoom_EmptyUsersList() {
	// arrange
	roomID := "1"

	inviter := &model.User{
		ID:       1,
		Username: "hostuser",
		Email:    "host@test.com",
	}

	users := &[]model.User{} // Empty list
	message := "Please join my room!"

	// act
	invites, err := s.roomService.InviteUserToRoom(roomID, inviter, users, message)

	// assert
	assert.NoError(s.T(), err)
	assert.NotNil(s.T(), invites)
	assert.Len(s.T(), *invites, 0)
}

func (s *RoomServiceTestSuite) TestRemoveUserFromRoom_Success() {
	// arrange
	roomID := "1"
	userID := "2"

	// Delete user from room
	s.mock.ExpectExec(`DELETE FROM room_users WHERE room_id = \$1 AND user_id = \$2`).
		WithArgs(roomID, userID).
		WillReturnResult(sqlmock.NewResult(1, 1))

	// act
	err := s.roomService.RemoveUserFromRoom(roomID, userID)

	// assert
	assert.NoError(s.T(), err)
}

func (s *RoomServiceTestSuite) TestGetUninvitedFriendsForRoom_Success() {
	// arrange
	roomID := "1"
	userID := "1"
	now := time.Now()

	expectedFriends := []model.User{
		{
			ID:           2,
			Username:     "friend1",
			Email:        "friend1@test.com",
			RegisteredAt: now,
			UpdatedAt:    now,
		},
		{
			ID:           3,
			Username:     "friend2",
			Email:        "friend2@test.com",
			RegisteredAt: now,
			UpdatedAt:    now,
		},
	}

	// Expected query will be complex with multiple joins and subqueries
	friendRows := sqlmock.NewRows([]string{
		"id", "username", "email", "password", "picture_url",
		"is_email_valid", "is_online", "last_seen", "registered_at", "updated_at",
	})

	for _, friend := range expectedFriends {
		friendRows.AddRow(
			friend.ID, friend.Username, friend.Email, "password", "",
			true, false, now, now, now,
		)
	}

	// Simplified regex for the query
	// TODO: Check the correct query
	// s.mock.ExpectQuery(`SELECT DISTINCT.*? FROM "users".*? JOIN user_friends.*? WHERE.*? NOT IN.*? AND.*? NOT IN`).
	s.mock.ExpectQuery(`SELECT DISTINCT.*?`).
		WithArgs(userID, roomID, roomID).
		WillReturnRows(friendRows)

	// act
	friends, err := s.roomService.GetUninvitedFriendsForRoom(roomID, userID)

	// assert
	assert.NoError(s.T(), err)
	assert.NotNil(s.T(), friends)
	assert.Len(s.T(), *friends, 2)
	assert.Equal(s.T(), expectedFriends[0].ID, (*friends)[0].ID)
	assert.Equal(s.T(), expectedFriends[1].ID, (*friends)[1].ID)
}

func (s *RoomServiceTestSuite) TestGetUninvitedFriendsForRoom_NoFriends() {
	// arrange
	roomID := "1"
	userID := "1"

	// Return empty result
	friendRows := sqlmock.NewRows([]string{
		"id", "username", "email", "password", "picture_url",
		"is_email_valid", "is_online", "last_seen", "registered_at", "updated_at",
	})

	// Simplified regex for the query
	// TODO: Check the correct query
	// s.mock.ExpectQuery(`SELECT DISTINCT.*? FROM "users".*?J OIN user_friends.*? WHERE.*? NOT IN.*? AND.*? NOT IN`).
	s.mock.ExpectQuery(`SELECT DISTINCT.*?`).
		WithArgs(userID, roomID, roomID).
		WillReturnRows(friendRows)

	// act
	friends, err := s.roomService.GetUninvitedFriendsForRoom(roomID, userID)

	// assert
	assert.NoError(s.T(), err)
	assert.NotNil(s.T(), friends)
	assert.Len(s.T(), *friends, 0)
}
